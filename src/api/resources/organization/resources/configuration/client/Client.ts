// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../../../BaseClient.js";
import * as environments from "../../../../../../environments.js";
import * as core from "../../../../../../core/index.js";
import * as MyOrganization from "../../../../../index.js";
import { mergeHeaders } from "../../../../../../core/headers.js";
import * as errors from "../../../../../../errors/index.js";
import { IdentityProvidersClient } from "../resources/identityProviders/client/Client.js";

export declare namespace ConfigurationClient {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class ConfigurationClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ConfigurationClient.Options>;
    protected _identityProviders: IdentityProvidersClient | undefined;

    constructor(options: ConfigurationClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    public get identityProviders(): IdentityProvidersClient {
        return (this._identityProviders ??= new IdentityProvidersClient(this._options));
    }

    /**
     * Retrieve the configuration for the /my-org API. This will return all stored client information with the exception of attributes that are identifiers. Identifier attributes will be given their own endpoint that will return the full object. This will give the components all of the information they will need to be successful. The SDK provider for the components should manage fetching and caching this information for all components.
     *
     * @param {ConfigurationClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link MyOrganization.UnauthorizedError}
     * @throws {@link MyOrganization.ForbiddenError}
     * @throws {@link MyOrganization.NotFoundError}
     * @throws {@link MyOrganization.TooManyRequestsError}
     *
     * @example
     *     await client.organization.configuration.get()
     */
    public get(
        requestOptions?: ConfigurationClient.RequestOptions,
    ): core.HttpResponsePromise<MyOrganization.GetConfigurationResponseContent> {
        return core.HttpResponsePromise.fromPromise(this.__get(requestOptions));
    }

    private async __get(
        requestOptions?: ConfigurationClient.RequestOptions,
    ): Promise<core.WithRawResponse<MyOrganization.GetConfigurationResponseContent>> {
        const _metadata: core.EndpointMetadata = {
            security: [
                { OAuth2ClientCredentials: ["read:my_org:configuration"] },
                { OAuth2AuthCode: ["read:my_org:configuration"] },
            ],
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest({
            endpointMetadata: _metadata,
        });
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.MyOrganizationEnvironment.Default,
                "config",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            endpointMetadata: _metadata,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as MyOrganization.GetConfigurationResponseContent,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new MyOrganization.UnauthorizedError(
                        _response.error.body as MyOrganization.ErrorResponseContent,
                        _response.rawResponse,
                    );
                case 403:
                    throw new MyOrganization.ForbiddenError(
                        _response.error.body as MyOrganization.ErrorResponseContent,
                        _response.rawResponse,
                    );
                case 404:
                    throw new MyOrganization.NotFoundError(
                        _response.error.body as MyOrganization.ErrorResponseContent,
                        _response.rawResponse,
                    );
                case 429:
                    throw new MyOrganization.TooManyRequestsError(
                        _response.error.body as MyOrganization.ErrorResponseContent,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.MyOrganizationError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.MyOrganizationError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.MyOrganizationTimeoutError("Timeout exceeded when calling GET /config.");
            case "unknown":
                throw new errors.MyOrganizationError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }
}
