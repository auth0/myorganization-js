// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../../../BaseClient.js";
import * as environments from "../../../../../../environments.js";
import * as core from "../../../../../../core/index.js";
import * as Auth0MyOrg from "../../../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../../../core/headers.js";
import * as errors from "../../../../../../errors/index.js";

export declare namespace Configuration {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Configuration {
    protected readonly _options: Configuration.Options;

    constructor(_options: Configuration.Options) {
        this._options = _options;
    }

    /**
     * Retrieve the configuration for the /my-org API. This will return all stored client information with the exception of attributes that are identifiers. Identifier attributes will be given their own endpoint that will return the full object. This will give the components all of the information they will need to be successful. The SDK provider for the components should manage fetching and caching this information for all components.
     *
     * @param {Configuration.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Auth0MyOrg.UnauthorizedError}
     * @throws {@link Auth0MyOrg.ForbiddenError}
     * @throws {@link Auth0MyOrg.NotFoundError}
     * @throws {@link Auth0MyOrg.TooManyRequestsError}
     *
     * @example
     *     await client.organization.configuration.get()
     */
    public get(
        requestOptions?: Configuration.RequestOptions,
    ): core.HttpResponsePromise<Auth0MyOrg.GetConfigurationResponseContent> {
        return core.HttpResponsePromise.fromPromise(this.__get(requestOptions));
    }

    private async __get(
        requestOptions?: Configuration.RequestOptions,
    ): Promise<core.WithRawResponse<Auth0MyOrg.GetConfigurationResponseContent>> {
        const _metadata: core.EndpointMetadata = {
            security: [
                { OAuth2ClientCredentials: ["read:my_org:configuration"] },
                { OAuth2AuthCode: ["read:my_org:configuration"] },
            ],
        };
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader(_metadata) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.Auth0MyOrgEnvironment.Default,
                "config",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            endpointMetadata: _metadata,
        });
        if (_response.ok) {
            return {
                data: _response.body as Auth0MyOrg.GetConfigurationResponseContent,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Auth0MyOrg.UnauthorizedError(
                        _response.error.body as Auth0MyOrg.ErrorResponseContent,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Auth0MyOrg.ForbiddenError(
                        _response.error.body as Auth0MyOrg.ErrorResponseContent,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Auth0MyOrg.NotFoundError(
                        _response.error.body as Auth0MyOrg.ErrorResponseContent,
                        _response.rawResponse,
                    );
                case 429:
                    throw new Auth0MyOrg.TooManyRequestsError(
                        _response.error.body as Auth0MyOrg.ErrorResponseContent,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.Auth0MyOrgError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.Auth0MyOrgError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.Auth0MyOrgTimeoutError("Timeout exceeded when calling GET /config.");
            case "unknown":
                throw new errors.Auth0MyOrgError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(endpointMetadata: core.EndpointMetadata): Promise<string> {
        return `Bearer ${await core.EndpointSupplier.get(this._options.token, { endpointMetadata })}`;
    }
}
